| ID  | File / Area                                           | Task                                                                                                                                                                                                                                       | Outcome                                                                 |
| --- | ----------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------- |
| T-1 | `robots/tatbot/tatbot.py` — class init                | Replace the hard-coded 15-element `self.joints` list with a programmatic generator:<br>`self.joints = [f"{side}.{name}" for side in ("left","right") for name in ("joint_0","joint_1","joint_2","joint_3","joint_4","joint_5","gripper")]` | One authoritative definition; no manual edits when joint count changes. |
| T-2 | `tatbot.py` — `_get_positions_l` & `_get_positions_r` | Collapse the two nearly identical methods into one helper that takes `(driver_handle, fallback_pose, label)` and returns the list.                                                                                                         | DRY; lower maintenance overhead.                                        |
| T-3 | `tatbot.py` — `_set_positions_l` & `_set_positions_r` | a) Replace both with a single helper that receives the slice of `self.joints` it validates.<br>b) Vectorise mismatch check:<br>`deltas = np.abs(np.array(read) - np.array(goal))` and evaluate thresholds once.                            | Removes duplicate \~100 LoC; lowers per-call Python overhead.           |
| T-4 | `tatbot.py` — logging hotspots                        | Wrap heavy string-formatting calls with `if logger.isEnabledFor(logging.DEBUG):` before building them.                                                                                                                                     | Cuts control-loop latency when DEBUG disabled.                          |
| T-5 | `tatbot.py` — `get_observation`                       | Build motor-state dict in one go:<br>`obs.update({f"{j}.pos":v for j,v in zip(self.joints, joint_pos_l + joint_pos_r)})`                                                                                                                   | Fewer Python iterations, cleaner code.                                  |
| T-6 | `tatbot.py` — camera reads                            | Launch `cam.async_read()` calls in parallel with `concurrent.futures.ThreadPoolExecutor(max_workers=len(self.cameras))`; gather results. **Do this only in Tatbot, don’t modify camera classes.**                                          | Overlaps I/O, reduces total frame acquisition time.                     |
| T-7 | `tatbot.py` — `send_action`                           | 1. Issue both arm commands with `blocking=False`.<br>2. After both sends, poll or call a single wait helper to ensure completion when `block` was `"both"`.                                                                                | Arms move simultaneously → halves action latency.                       |
| T-8 | `tatbot.py` — `_urdf_joints_to_action`                | Replace manual field-by-field dict build with:<br>`return {f"{j}.pos": v for j, v in zip(self.joints, urdf_joints)}`                                                                                                                       | Removes fragile positional mapping (and the silent skip of index 7).    |

| ID  | File / Area                                           | Task                                                                                                                                                  | Outcome                                         |
| --- | ----------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------- |
| A-1 | `teleoperators/gamepad/atari_teleoperator.py` — queue | Consider `queue_size=0` (unbounded) and, inside `get_action`, drain the queue and keep only the *last* event to avoid silent drops and reallocations. | No lost inputs; simpler back-pressure handling. |
| A-2 | `_event_loop`                                         | Replace normalization line with<br>`norm = event.value / 127.5 - 1.0`                                                                                 | Slightly faster, fewer constants.               |
| A-3 | `_put_event`                                          | Count or log the number of times `queue.Full` occurs when using a bounded queue, so lag isn’t hidden.                                                 | Easier debugging of missed inputs.              |
